from __future__ import annotations

from collections import defaultdict
from pathlib import Path
from typing import Any, Collection, Iterable, Optional, Protocol

from CreeDictionary.CreeDictionary.paradigm.panes import Paradigm, ParadigmLayout

# I would *like* a singleton for this, but, currently, it interacts poorly with mypy :/
ONLY_SIZE = "<only-size>"


class ParadigmManager:
    """
    Mediates access to paradigms layouts.

    Loads layouts from the filesystem and can fill the layout with results from a
    (normative/strict) generator FST.
    """

    # Mappings of paradigm name => sizes available => the layout/paradigm
    _name_to_paradigm: dict[str, dict[str, Paradigm]]
    _wc_to_layout: dict[str, dict[str, ParadigmLayout]]

    def __init__(self, layout_directory: Path, generation_fst: Transducer):
        self._generator = generation_fst
        self._name_to_paradigm = defaultdict(dict)
        self._wc_to_layout = defaultdict(dict)

        self._load_static_from(layout_directory / "static")
        self._load_dynamic_from(layout_directory / "dynamic")

    def static_paradigm_for(self, name: str) -> Optional[Paradigm]:
        """
        Returns a static paradigm with the given name.
        Returns None if there is no paradigm with such a name.
        """
        if size_options := self._name_to_paradigm.get(name):
            return size_options[ONLY_SIZE]
        return None

    def dynamic_paradigm_for(
        self, *, lemma: str, word_class: str
    ) -> Optional[Paradigm]:
        """
        Returns a dynamic paradigm for the given lemma and word class.
        Returns None if no such paradigm can be generated.
        """
        size_options = self._wc_to_layout.get(word_class)
        if size_options is None:
            # No matching name means no paradigm:
            return None

        layout = size_options[ONLY_SIZE]
        return self._inflect(layout, lemma)

    def sizes_of(self, paradigm_name: str) -> Collection[str]:
        """
        Returns the size options of the given paradigm.
        """
        collection: dict[str, dict[str, Any]]

        if paradigm_name in self._name_to_paradigm:
            collection = self._name_to_paradigm
        elif paradigm_name in self._wc_to_layout:
            collection = self._wc_to_layout
        else:
            raise KeyError(f"Paradigm does not exist: {paradigm_name}")

        return collection[paradigm_name].keys()

    def _load_static_from(self, path: Path):
        """
        Loads all .tsv files in the path as static paradigms.
        """
        for paradigm_name, layout in self._load_all_layouts_in_directory(path):
            self._name_to_paradigm[paradigm_name][
                ONLY_SIZE
            ] = layout.as_static_paradigm()

    def _load_dynamic_from(self, path: Path):
        """
        Loads all .tsv files as dynamic layouts.
        """
        for paradigm_name, layout in self._load_all_layouts_in_directory(path):
            self._wc_to_layout[paradigm_name][ONLY_SIZE] = layout

    def _inflect(self, layout: ParadigmLayout, lemma: str) -> Paradigm:
        """
        Given a layout and a lemma, produce a paradigm with forms generated by the FST.
        """
        template2analysis = layout.generate_fst_analyses(lemma=lemma)
        analysis2forms = self._generator.bulk_lookup(list(template2analysis.values()))
        template2forms = {
            template: analysis2forms[analysis]
            for template, analysis in template2analysis.items()
        }
        return layout.fill(template2forms)

    @staticmethod
    def _load_all_layouts_in_directory(path: Path):
        for layout_file in path.glob("*.tsv"):
            layout = ParadigmLayout.loads(layout_file.read_text(encoding="UTF-8"))
            yield layout_file.stem, layout


class Transducer(Protocol):
    """
    Interface for something that can lookup forms in bulk.

    This is basically the subset of the hfst_optimized_lookup.TransducerFile API that
    the paradigm manager actually uses.
    """

    def bulk_lookup(self, strings: Iterable[str]) -> dict[str, set[str]]:
        ...
